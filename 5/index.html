<!DOCTYPE html>
<html>
  <head>
  <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <meta name="author" content="" />

    <link rel="stylesheet" type="text/css" href="http://localhost:4000/css/root.css" media="screen" />
    <script type="text/javascript" src="http://localhost:4000/js/prefixfree.min.js"></script>

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <title>Content generation and version tracking across branches</title>
  </head>
  
  	<body class="id_5">
  
  
 
 
<header>
	<nav>
		
		
		
			
			
			
			
				
					
					

			
			

			
			
				
				

				<a title="" href="http://localhost:4000/4/">previous</a>
				<a class="disabled">next</a>
			
			
			
			<a href="http://localhost:4000">home</a>
			
		
	</nav>
</header>


	<article>
	
	
	<h1 >
		
			Content generation and version tracking across branches
		
</h1>
	
<p>
	Generating content locally and pushing it to specific content branch
</p>

	
	<ol>
<li><a href="#Background">Background</a></li>
<li><a href="#Problem">Problem</a></li>
<li><a href="#Solution">Solution</a></li>
</ol>


                            <h2  id="Background">
                                <a href="#Background">Background</a>
                                <a href="#top"> *</a>
                            </h2>


<p>If you haven't noticed, very header on this site is a link. This is so that you can share a specific portion of a post, much in the same way <a href="http://en.wikipedia.org/wiki/Wikipedia:About#About_Wikipedia">Wikipedia</a> works.
Now, when I built this site, I wanted the markup to have as much semantic meaning as possible, meaning that every id, every class and basically every tag has to make sense without CSS or Javascript (I'm not there yet, though! Try visiting the website through <a href="http://lynx.browser.org/">lynx</a>).</p>

<p>One of the weakest links of what I've had the time to do as of today, was the page intralink functionality I spoke of above. The way it was set up, was that when the page is loaded and ready, [a small script][1] inserted links to every header on the page.</p>

<p>Now, you might wonder: "But Marcus, how do browsers such as lynx, or Google Bot see these links?"
Truth is: They don't.</p>

<p>The first thing I did to remedy the situation, was to throw the Javascript "solution" out the window. It was a quick hack at best, and I honestly don't know what I thought when I pushed it live.</p>

                            <h2  id="Ruby-to-the-rescue">
                                <a href="#Ruby-to-the-rescue">Ruby to the rescue</a>
                                <a href="#top"> *</a>
                            </h2>


<p><a href="http://jekyllrb.com">Jekyll</a> is built using <a href="https://www.ruby-lang.org/">Ruby</a>. By extension, so is the <a href="/">site</a> you're reading now.
Jekyll is extensible, and any files matching <code>_plugins/*.rb</code> from within your source directory will be loaded into the generation runtime.</p>

<p>Using this pattern you can create <a href="http://jekyllrb.com/docs/plugins/#generators">Generators</a> that generate new content, <a href="http://jekyllrb.com/docs/plugins/#converters">Converters</a> that convert source content into something else, and bascially anything you can do using Ruby (Read: anything, <a href="http://en.wikipedia.org/wiki/Turing_Complete">click here</a>).</p>

<p>My solution to our little <a href="http://defav.lt/4/#Background">problem</a> was to plop a <code>Converter</code> into the <code>_plugins</code> directory, <a href="http://en.wikipedia.org/wiki/Monkey_patch">monkey patch</a> the Markdown engine I use (<a href="https://github.com/davidfstr/rdiscount">RDiscount</a>) and overload the <code>convert</code> method.</p>

                            <h2  id="The-structure-of-plugins-for-Jekyll">
                                <a href="#The-structure-of-plugins-for-Jekyll">The structure of plugins for Jekyll</a>
                                <a href="#top"> *</a>
                            </h2>


<p>For starters, add this to your file:</p>

<pre><code>#_plugins/converter.rb:

module Jekyll
    module Converters
        class Markdown
            class RDiscountParser

            end
        end
    end
end
</code></pre>

<p>Go ahead and open up a parser of your choice. I'm using RDiscount, so that's what I used. Your parser might not reside in <code>Jekyll::Converters::Markdown</code>, so check your documentation!</p>

<p>While we're at it, toss this into the mix:</p>

<pre><code>#_plugins/converter.rb:
# [..]

alias_method :original_convert, :convert

def convert(content)
    return original_convert(content)
end

# [..]
</code></pre>

<p>What this does, is that it creates an alias to the <em>original <code>convert</code> method</em> so we can use our own version as well.</p>

<p><strong>NOTE:</strong> <em>I know many old-timers with Ruby will scream and bang their head at me for using the <code>return</code> statement. But since I use a multitude of languages every single day, I prefer to stick to a syntax that's </em>familiar<em>. Readability over standards in my case, unfortunately.</em></p>

<p>Next, add these two methods so Jekyll will know which files we should process:</p>

<pre><code>#_plugins/converter.rb:
# [..]

def matches(ext)
    return ext =~ /^\.html$/i
end

def output_ext(ext)
    return ext
end

# [..]
</code></pre>

<p>Simple enough. Match all <code>.html</code> files and output an extension we want (of course, modify these however you want).</p>

<p>This is really all you need to know to extend your Parser. Put your logic in <code>convert</code> and modify <code>content</code> however you see fit. The next chapters in this little tutorial will go into depth both with how Regular Expressions work and, more specifically, how I solved my particular problem using it.</p>

                            <h2  id="Matching-tags-with-RegExp">
                                <a href="#Matching-tags-with-RegExp">Matching tags with RegExp</a>
                                <a href="#top"> *</a>
                            </h2>


<p>Oh god, <a href="http://stackoverflow.com/a/1732454">were</a> do we <a href="http://blog.codinghorror.com/parsing-html-the-cthulhu-way/">begin</a>.</p>

<p>Seriously though, don't be alarmed. What I have here, is a set of pages with a <em>perfectly known pattern</em>. Not some random X/HTML from some random, half-broken website from India (no offence meant if you're from India and <em>good at what you do</em>). The text that needs to match, will never, <em>ever</em> contain:</p>

<ul>
<li>Anything other than tags h1-h6</li>
<li><em>Malformed</em> expressions (i.e. broken tags)</li>
<li>Odd unicode characters</li>
</ul>


<p>Here's a sample of what's allowed or not:</p>

<pre><code># Allowed
&lt;h2&gt;&lt;/h2&gt;
&lt;h3&gt;abcdef&lt;/h3&gt;
&lt;h4 abc&gt;&lt;/h4&gt;
&lt;h4 abc="def"&gt;&lt;/h4&gt;
&lt;h4 abc="def" def&gt;ABCdef&lt;/h4&gt;

# Disallowed
&lt;h2 /&gt;
&lt;/h2&gt;
&lt;h1&gt;&lt;/h1&gt;
&lt;h3
&lt;h3bb&gt;&lt;/h3bb&gt;
</code></pre>

<p>Now, let's begin by matching a single, open tag. <code>&lt;h1&gt;</code> should not match, and <code>&lt;h3&gt;</code> should. Simple as that.</p>

<pre><code>START_PATTERN = /\&lt;(?&lt;tag&gt;h[2-6])\s*\&gt;/
</code></pre>

<p>Simple, isn't it? Our little sentence of the language from <strong>hell</strong> matches what it should, and all is well.</p>

<p>To explain it a bit further:</p>

<table>
<thead>
<tr>
<th> Expression    </th>
<th> Explanation </th>
</tr>
</thead>
<tbody>
<tr>
<td> (?<tag>x)     </td>
<td> Put any expression where the <code>x</code> is and you've got yourself a named group, Mister.</td>
</tr>
<tr>
<td> h[2-6]        </td>
<td> Matches an <code>h</code> plus any single digit between <code>2-6</code>.</td>
</tr>
<tr>
<td> \s            </td>
<td> Matches any whitespace (that is, <strong>space</strong>)</td>
</tr>
<tr>
<td> &lt; or >      </td>
<td> Matches the <code>&lt;</code> and <code>&gt;</code> signs, respectively.</td>
</tr>
</tbody>
</table>


<p>There we go. Not so hard. As you'll see later, the <code>(?&lt;tag&gt;x)</code> expression will make a value named <code>tag</code> available for us to in the code.</p>

<p>What if we wanted to match an end tag (i.e. <code>&lt;/tag&gt;</code>)? Well, add a single thing, and you've got yourself something regular (pun intended, now laugh).</p>

<pre><code>END_PATTERN = /\&lt;\/(?&lt;tag&gt;h[2-6]\&lt;/
</code></pre>

<p>See the difference? Take a look at the beginning: I added <code>\/</code>.</p>

<p>Now, let's expand this so it recognizes <em>attributes</em> on the start tag.</p>

<p>The syntax for attributes in X/HTML is as follows: <code>key=(" | ')value(" | ')</code>.</p>

<p>Take a note of the <code>(" | ')</code>. Those means the boundary of the value can be <em>either</em> <code>'</code> or <code>"</code>. Tricky, tricky. But not impossible!</p>

<pre><code>(?&lt;attr&gt;(\w+(\=(\"|\')(\w|\s)*(\"|\'))?\s*))
</code></pre>

<p>Oh, crap. That's long. Here's a breakdown:</p>

<table>
<thead>
<tr>
<th> Expression </th>
<th> Explanation </th>
</tr>
</thead>
<tbody>
<tr>
<td> (\w ..)?   </td>
<td> Match a single or no value</td>
</tr>
<tr>
<td> \w+        </td>
<td> Match any (<code>*</code>) number of words (<code>\w</code>).</td>
</tr>
<tr>
<td> (\"|\')    </td>
<td> Match either a <code>"</code> or a <code>'</code>.</td>
</tr>
<tr>
<td> (\w|\s)*   </td>
<td> Match any number of words of whitespace characters</td>
</tr>
</tbody>
</table>


<p>Again, not so hard if you break it down. Add these two together, and you'll match any hX tag <em>without any content between the opening and closing tag</em>.
If you put content there, it'll break.</p>

<p>So how do we add a match for content, you say? Well, quite easily actually.</p>

<pre><code>(?&lt;content&gt;(\w|\s|\d|\n|[\!\"\#\&amp;\(\)\=\?\\\/\.-])*)?
</code></pre>

<table>
<thead>
<tr>
<th style="text-align:left;"> Expression         </th>
<th style="text-align:left;"> Explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> (\d|\n|[..] etc) </td>
<td style="text-align:left;"> Match the characters defined within the capturing group (\d stands for <em>d</em>igits)</td>
</tr>
</tbody>
</table>


<p>So long, but still so little. Put this between the opening and ending tag expression, and you're good to go.</p>

<pre><code>module Jekyll
    module Converters
        class Markdown
            class RDiscountParser

                #Matches any h2-h6 tag with or without attributes
                START_PATTERN = /\&lt;(?&lt;tag&gt;h[2-6])\s*(?&lt;attr&gt;(\w+(\=(\"|\')(\w|\s)*(\"|\'))*\s*)*)\&gt;/

                #Matches any ending h2-h6 tag
                END_PATTERN = /\&lt;\/\s*(?&lt;tag&gt;h[0-6])\s*\&gt;/

                #The tag that was matched in START_PATTER, END_PATTER and the content between them
                CONTENT = /\&lt;(?&lt;tag&gt;h[2-6])\s*(?&lt;attr&gt;(\w+(\=(\"|\')(\w|\s)*(\"|\'))*\s*)*)\&gt;(?&lt;content&gt;(\w|\s|\d|\n|[\!\"\#\&amp;\(\)\=\?\\\/\.-])*)?\&lt;\/\s*(?&lt;tag&gt;h[0-6])\s*\&gt;/

                def matches(ext)
                    ext =~ /^\.html$/i
                end

                def output_ext(ext)
                    ext
                end

                alias_method :original_convert, :convert
                def convert(content)

                    return original_convert(content).gsub CONTENT do |match|
                        #Remember
                        #content = the content between the tag
                        #attr = the attributes of the tag
                        #tag = the tag itself

                        tag = $~[:tag]
                        attr = $~[:attr]
                        content = $~[:content]
                        id = content.gsub /\s+/, '-'

                        # After formatting:
                        # &lt;hx x="y"&gt;
                        #  &lt;a href="#Some-Header"&gt;Some Header&lt;/a&gt;
                        #  &lt;a href="#top"&gt; *&lt;/a&gt;
                        # &lt;/hx&gt;
                        &lt;&lt;-eos
                            &lt;#{tag} #{attr} id=\"#{id}\"&gt;
                                &lt;a href=\"\##{id}\"&gt;#{content}&lt;/a&gt;
                                &lt;a href="#top"&gt; *&lt;/a&gt;
                            &lt;/#{tag}&gt;"
                        eos
                    end
                end
            end
        end
    end
end
</code></pre>

                            <h2  id="Remark">
                                <a href="#Remark">Remark</a>
                                <a href="#top"> *</a>
                            </h2>


<p>Worth noting, is that even though I use this on my own site, it's not <em>in the wild</em>. I use this every 50003432343 year or so when I create a new post and have to regenerate my site. I would never use this somewhat hacky solution on something that's "public facing", i.e. in a RoR controller or something, for that I'd opt for a full-fleshed parser (perhaps <a href="http://nokogiri.org/">Nokogiri</a>?).</p>

</article>
	
  </body>
  
  <link rel="stylesheet" href="//yandex.st/highlightjs/8.0/styles/tomorrow-night-bright.min.css">
  <script src="http://yandex.st/highlightjs/8.0/highlight.min.js"></script>

  <script type="text/javascript" src="//code.jquery.com/jquery-1.10.2.min.js"></script>
  <script type="text/javascript" src="http://localhost:4000/js/root.js"></script>

  <script type="text/javascript">
    if (hljs !== undefined)
        hljs.initHighlightingOnLoad();
  </script>
</html>
